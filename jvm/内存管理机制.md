# jvm 内存管理机制

## 领域划分

1. java Card 运行小内存设备， 智能卡平台
1. java ME 手机，精简 Java API
1. java SE 核心 Java API
1. java EE & j2ee 企业级 java se API + 扩充

## 运行数据区

### 线程独占区域

- 程序计数器
  - 每个线程有独自的程序计数器， java 程序解析器执行解析
- 虚拟机栈。
  - 方法执行， 创建 Stack Frame (栈帧)， 执行完成出帧
  - 方法区，boolean byte short ... 对象引用(指针)， 都会编译好， 计算出 Stack Frame 大小。
  - 栈深度， 最大长度， 分配空间。 允许扩大栈长度， 否则 OutOfMemoryError 方式
- 本地方法栈
  - 本地 Native 方法执行区域 （StackOverFLow, OutOfMemory）

### 线程共享区域

- 方法区
  - 存储 Class Info, 常量，静态变量。 non-heap
    - 运行时 常量池， Class Load 加载常量信息。 具备动态性。 常量池 也会 OutOfMemory 情况
  - Permanent Generation 永生代的大小， -XX:MaxPermSize 指定执行大小
- 堆 (Heap) GC 的主要区域
    - 不同的空间分配， 
    - 通过 -Xms -Xmx 控制

### 直接内存

- Native 直接分配的内存， DirectByteBuffer， 避免堆 Native 数据来回复制。
- 也就是 每个 Thread 运行都会有自己的 存储。

## 内存对象

### 内存对象分配

- 维护， 内存分配的列表，
- 保证内存分配的原子性， 或按照线程的内存分配方式
- 内存分配完成初始化
  - 对象必要设置： 1 类元数据, 对象 Hash 码，GC的年龄代，2 偏向锁，等 。 执行完成 多有的 都是 0.
  - init 初始化， 初始化对象

### 对象的布局

- 对象头 Header (1 存储运行数据，HashCode, GC 年龄代，锁状态表示，线程持有的锁，偏向线程 ID， 时间，)
- 实例数据 Instance Data （对象的数据信息）
- 对齐填充 Padding （占位符 8bit）

### 内存对象的定位

1. 通过句柄池 reference -> 句柄池 -> 句柄实例
1. Reference 对象 直接引用。

### 虚拟机对象创建 （普通对象创建）

- 常量池， 类 加载， 解析， 初始化
- 分配内存大小
- 初始化内存大小
- 引用 赋值 地址

## 实战

1. Heap 堆内存溢出， -Xmx -Xms 参数调整
1. Stack 栈溢出， -Xss 指定栈 大小。 方法区 线程创建
1. 方法区 常量池 内存溢出。 PermGen Space 大小 (string.intern 返回常量池的对象。 实际创建 String 的对象，是堆中的对象)
1. 本机直接内存溢出。 unsafe.allocateMemory(size), 没有 Heap, Stack 的溢出信息。

## 垃圾对象的分配回收策略 （内存回收位置： java堆区， 方法区）

### 对象回收

- 引用计数法， "1" 存在对象引用， "0" 不存在对象引用。 （一般虚拟机不采用， 难解决循环引用问题 a.in = b b.in = a,无法回收）
- 可达性分析算法 （主流 Java 语言使用）
  - GCRoot 可达的对象不回收， 不可达，即使有引用，回收
  - GCRoot 包含： 1 虚拟机栈 2 方法区静态引用对象 3 方法区常量对象 4 本地方法栈中 JNI, Native 方法。

### 引用， 内存足够，不回收，内存不够回收

- 强引用 永远不会回收
- 软引用， 有用非必须， 这些对象会被二次回收。
- 弱引用，一次回收， 回收对象。
- 虚引用，最弱，仅仅对象垃圾回收接到通知。

### 生存 死亡

> 首次标记， 回收对象， 仅仅 finlize() 方法对象可以自救

### 回收方法区

- 方法区，回收率很低， 一般新生代回收率较高(70 ~ 75)。
- 永久代 = 废弃常量 + 无用的 Class(定义： 1 对 不存在任何实例 2 改类 ClassLoader 回收 3 java.lang.Class 没有引用) ！！ 自定义 ClassLoader 需要

### 垃圾收集算法 不同平台定义

- 标记清除 （Mark-Sweep）
  - 1 效率不高 2 内存碎片化， 触发垃圾收集
- 复制算法： 内存分成两块， 使用一块， 当一块满的时候， 复制到另一块（解决了碎片化）， 清除碎片化， 满的一块。
  - 不一定 1 ： 1, 新生代回收的效率较高。 1： 8
  - 存活的对象 较多
- 标记，整理（不想浪费）
  - 通过内存的移动
- 分代算法
  - 新生代， 复制
  - 老生代，标记清理， 标记整理

### hotSpot 算法实现

- GC 发生 stop the world
- 通过OopMap, 指定不同的Object 的位置
- 程序运行 safepoint:循环，跳转异常等
  - 抢断中断：线程安全点中断。
  - 主动中断：设置表示，线程中断。

### 垃圾搜集产品

#### 新生代收集器

- Serial 执行收集的时候， STW 停止所有的线程
- ParNew Serial 多线程的版本， 可以与CMS 并行的执行方式
- Parallel Scavenage 收集器

#### 老生代收集器

- Serial Old
- Paralled Old
- CMS 收集器
  - 步骤
    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
- G1收集器

## 内存的分配策略

- 默认 创建对象分配在 新生代 Eden, 满， 发生一次 minGc(频繁， 比较快)
- 老年代GC , (Major Gc/ Full GC), 速度 慢十倍。
- 大对象直接进入 老年代， 避免 销毁比较快的 大对象。！！！
- 对象多次 GC 没有被销毁， 就会进入老年代
- 内存空间分配

TODO 4 character 
# jvm 内存管理机制

## 领域划分
1. java Card 运行小内存设备， 智能卡平台
2. java ME 手机，精简 Java API
3. java SE 核心 Java API
4. java EE & j2ee 企业级 java se API + 扩充

## 运行数据区
### 线程独占区域
- 程序计数器 
  - 每个线程有独自的程序计数器， java 程序解析器执行解析
- 虚拟机栈。 
  - 方法执行， 创建 Stack Frame (栈帧)， 执行完成出帧
  - 方法区，boolean byte short ... 对象引用(指针)， 都会编译好， 计算出 Stack Frame 大小。
  - 栈深度， 最大长度， 分配空间。 允许扩大栈长度， 否则 OutOfMemoryError 方式
- 本地方法栈
  - 本地 Native 方法执行区域 （StackOverFLow, OutOfMemory）
### 线程共享区域
- 方法区
  - 存储 Class Info, 常量，静态变量。 non-heap
    - 运行时 常量池， Class Load 加载常量信息。 具备动态性。 常量池 也会 OutOfMemory 情况
  - Permanent Generation 永生代的大小， -XX:MaxPermSize 指定执行大小
- 堆 (Heap) GC 的主要区域
    - 不同的空间分配， 
    - 通过 -Xms -Xmx 控制
### 直接内存
- Native 直接分配的内存， DirectByteBuffer， 避免堆 Native 数据来回复制。
- 也就是 每个 Thread 运行都会有自己的 存储。

## 内存对象
### 内存对象分配
- 维护， 内存分配的列表，
- 保证内存分配的原子性， 或按照线程的内存分配方式
- 内存分配完成初始化
  - 对象必要设置： 1 类元数据, 对象 Hash 码，GC的年龄代，2 偏向锁，等 。 执行完成 多有的 都是 0.
  - init 初始化， 初始化对象

### 对象的布局
- 对象头 Header (1 存储运行数据，HashCode, GC 年龄代，锁状态表示，线程持有的锁，偏向线程 ID， 时间，)
- 实例数据 Instance Data （对象的数据信息）
- 对齐填充 Padding （占位符 8bit）

### 内存对象的定位
1. 通过句柄池 reference -> 句柄池 -> 句柄实例
2. Reference 对象 直接引用。

### 虚拟机对象创建 （普通对象创建）
- 常量池， 类 加载， 解析， 初始化
- 分配内存大小
- 初始化内存大小
- 引用 赋值 地址


## 实战
1. Heap 堆内存溢出， -Xmx -Xms 参数调整
2. Stack 栈溢出， -Xss 指定栈 大小。 方法区 线程创建
3. 方法区 常量池 内存溢出。 PermGen Space 大小 (string.intern 返回常量池的对象。 实际创建 String 的对象，是堆中的对象)
4. 本机直接内存溢出。 unsafe.allocateMemory(size), 没有 Heap, Stack 的溢出信息。

## 垃圾对象的分配回收策略 （内存回收位置： java堆区， 方法区）
### 对象回收
- 引用计数法， "1" 存在对象引用， "0" 不存在对象引用。 （一般虚拟机不采用， 难解决循环引用问题 a.in = b b.in = a,无法回收）
- 可达性分析算法 （主流 Java 语言使用）
  - GCRoot 可达的对象不回收， 不可达，即使有引用，回收
  - GCRoot 包含： 1 虚拟机栈 2 方法区静态引用对象 3 方法区常量对象 4 本地方法栈中 JNI, Native 方法。

### 引用， 内存足够，不回收，内存不够回收
- 强引用 永远不会回收
- 软引用， 有用非必须， 这些对象会被二次回收。
- 弱引用，一次回收， 回收对象。
- 虚引用，最弱，仅仅对象垃圾回收接到通知。

### 生存 死亡
> 首次标记， 回收对象， 仅仅 finlize() 方法对象可以自救

### 回收方法区
- 方法区，回收率很低， 一般新生代回收率较高(70 ~ 75)。
- 永久代 = 废弃常量 + 无用的 Class(定义： 1 对 不存在任何实例 2 改类 ClassLoader 回收 3 java.lang.Class 没有引用) ！！ 自定义 ClassLoader 需要

### 垃圾收集算法
- 标记清楚 69Page 
